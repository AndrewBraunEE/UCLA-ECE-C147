<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=None">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">nndl.layers</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">pdb</span>

<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot; </span>
<span style="color: #BA2121; font-style: italic">This code was originally written for CS 231n at Stanford University</span>
<span style="color: #BA2121; font-style: italic">(cs231n.stanford.edu).  It has been modified in various areas for use in the</span>
<span style="color: #BA2121; font-style: italic">ECE 239AS class at UCLA.  This includes the descriptions of what code to</span>
<span style="color: #BA2121; font-style: italic">implement as well as some slight potential changes in variable names to be</span>
<span style="color: #BA2121; font-style: italic">consistent with class nomenclature.  We thank Justin Johnson &amp; Serena Yeung for</span>
<span style="color: #BA2121; font-style: italic">permission to use this code.  To see the original version, please visit</span>
<span style="color: #BA2121; font-style: italic">cs231n.stanford.edu.  </span>
<span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">conv_forward_naive</span>(x, w, b, conv_param):
  <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">  A naive implementation of the forward pass for a convolutional layer.</span>

<span style="color: #BA2121; font-style: italic">  The input consists of N data points, each with C channels, height H and width</span>
<span style="color: #BA2121; font-style: italic">  W. We convolve each input with F different filters, where each filter spans</span>
<span style="color: #BA2121; font-style: italic">  all C channels and has height HH and width HH.</span>

<span style="color: #BA2121; font-style: italic">  Input:</span>
<span style="color: #BA2121; font-style: italic">  - x: Input data of shape (N, C, H, W)</span>
<span style="color: #BA2121; font-style: italic">  - w: Filter weights of shape (F, C, HH, WW)</span>
<span style="color: #BA2121; font-style: italic">  - b: Biases, of shape (F,)</span>
<span style="color: #BA2121; font-style: italic">  - conv_param: A dictionary with the following keys:</span>
<span style="color: #BA2121; font-style: italic">    - &#39;stride&#39;: The number of pixels between adjacent receptive fields in the</span>
<span style="color: #BA2121; font-style: italic">      horizontal and vertical directions.</span>
<span style="color: #BA2121; font-style: italic">    - &#39;pad&#39;: The number of pixels that will be used to zero-pad the input.</span>

<span style="color: #BA2121; font-style: italic">  Returns a tuple of:</span>
<span style="color: #BA2121; font-style: italic">  - out: Output data, of shape (N, F, H&#39;, W&#39;) where H&#39; and W&#39; are given by</span>
<span style="color: #BA2121; font-style: italic">    H&#39; = 1 + (H + 2 * pad - HH) / stride</span>
<span style="color: #BA2121; font-style: italic">    W&#39; = 1 + (W + 2 * pad - WW) / stride</span>
<span style="color: #BA2121; font-style: italic">  - cache: (x, w, b, conv_param)</span>
<span style="color: #BA2121; font-style: italic">  &quot;&quot;&quot;</span>
  out <span style="color: #666666">=</span> <span style="color: #008000">None</span>
  pad <span style="color: #666666">=</span> conv_param[<span style="color: #BA2121">&#39;pad&#39;</span>]
  stride <span style="color: #666666">=</span> conv_param[<span style="color: #BA2121">&#39;stride&#39;</span>]

  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># YOUR CODE HERE:</span>
  <span style="color: #408080; font-style: italic">#   Implement the forward pass of a convolutional neural network.</span>
  <span style="color: #408080; font-style: italic">#   Store the output as &#39;out&#39;.</span>
  <span style="color: #408080; font-style: italic">#   Hint: to pad the array, you can use the function np.pad.</span>
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  npad <span style="color: #666666">=</span> ((<span style="color: #666666">0</span>,<span style="color: #666666">0</span>),(<span style="color: #666666">0</span>,<span style="color: #666666">0</span>),(pad,pad),(pad,pad))
  xpad <span style="color: #666666">=</span> np<span style="color: #666666">.</span>pad(x, pad_width <span style="color: #666666">=</span> npad, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;constant&#39;</span>, constant_values<span style="color: #666666">=0</span>)
  N,C,H,W <span style="color: #666666">=</span> xpad<span style="color: #666666">.</span>shape
  F,C,HH,WW <span style="color: #666666">=</span> w<span style="color: #666666">.</span>shape
  H_pad <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> (H <span style="color: #666666">+</span> <span style="color: #666666">0</span> <span style="color: #666666">*</span> pad <span style="color: #666666">-</span> HH) <span style="color: #666666">/</span> stride)
  W_pad <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> (W <span style="color: #666666">+</span> <span style="color: #666666">0</span> <span style="color: #666666">*</span> pad <span style="color: #666666">-</span> WW) <span style="color: #666666">/</span> stride)
  out <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N,F,H_pad, W_pad))

  <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(F):
      <span style="color: #008000; font-weight: bold">for</span> h <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(H_pad):
        hs <span style="color: #666666">=</span> h <span style="color: #666666">*</span> stride
        <span style="color: #008000; font-weight: bold">for</span> ii <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(W_pad):
          ws <span style="color: #666666">=</span> ii <span style="color: #666666">*</span> stride
          out[n,f,h,ii] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(w[f]<span style="color: #666666">*</span>xpad[n,:,hs:hs<span style="color: #666666">+</span>HH,ws:ws<span style="color: #666666">+</span>WW]) <span style="color: #666666">+</span> b[f]

  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># END YOUR CODE HERE</span>
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
    
  cache <span style="color: #666666">=</span> (x, w, b, conv_param)
  <span style="color: #008000; font-weight: bold">return</span> out, cache


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">conv_backward_naive</span>(dout, cache):
  <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">  A naive implementation of the backward pass for a convolutional layer.</span>

<span style="color: #BA2121; font-style: italic">  Inputs:</span>
<span style="color: #BA2121; font-style: italic">  - dout: Upstream derivatives.</span>
<span style="color: #BA2121; font-style: italic">  - cache: A tuple of (x, w, b, conv_param) as in conv_forward_naive</span>

<span style="color: #BA2121; font-style: italic">  Returns a tuple of:</span>
<span style="color: #BA2121; font-style: italic">  - dx: Gradient with respect to x</span>
<span style="color: #BA2121; font-style: italic">  - dw: Gradient with respect to w</span>
<span style="color: #BA2121; font-style: italic">  - db: Gradient with respect to b</span>
<span style="color: #BA2121; font-style: italic">  &quot;&quot;&quot;</span>
  dx, dw, db <span style="color: #666666">=</span> <span style="color: #008000">None</span>, <span style="color: #008000">None</span>, <span style="color: #008000">None</span>

  N, F, out_height, out_width <span style="color: #666666">=</span> dout<span style="color: #666666">.</span>shape
  x, w, b, conv_param <span style="color: #666666">=</span> cache
  
  stride, pad <span style="color: #666666">=</span> [conv_param[<span style="color: #BA2121">&#39;stride&#39;</span>], conv_param[<span style="color: #BA2121">&#39;pad&#39;</span>]]
  xpad <span style="color: #666666">=</span> np<span style="color: #666666">.</span>pad(x, ((<span style="color: #666666">0</span>,<span style="color: #666666">0</span>), (<span style="color: #666666">0</span>,<span style="color: #666666">0</span>), (pad,pad), (pad,pad)), mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;constant&#39;</span>)
  num_filts, _, f_height, f_width <span style="color: #666666">=</span> w<span style="color: #666666">.</span>shape

  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># YOUR CODE HERE:</span>
  <span style="color: #408080; font-style: italic">#   Implement the backward pass of a convolutional neural network.</span>
  <span style="color: #408080; font-style: italic">#   Calculate the gradients: dx, dw, and db.</span>
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  N,C,H,W <span style="color: #666666">=</span> x<span style="color: #666666">.</span>shape
  H_pad <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> (H <span style="color: #666666">+</span> <span style="color: #666666">2*</span>pad <span style="color: #666666">-</span> f_height) <span style="color: #666666">/</span> stride)
  W_pad <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> (W <span style="color: #666666">+</span> <span style="color: #666666">2</span> <span style="color: #666666">*</span> pad <span style="color: #666666">-</span> f_width) <span style="color: #666666">/</span> stride)

  dxpad <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(xpad)
  dx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(x)
  dw <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(w)
  db <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(b)

  <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
    <span style="color: #008000; font-weight: bold">for</span> f <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_filts):
      db[f] <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>sum(dout[n, f])
      <span style="color: #008000; font-weight: bold">for</span> jj <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(H_pad):
        hs <span style="color: #666666">=</span> jj<span style="color: #666666">*</span>stride
        <span style="color: #008000; font-weight: bold">for</span> ii <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(W_pad):
          ws <span style="color: #666666">=</span> ii <span style="color: #666666">*</span> stride
          dw[f] <span style="color: #666666">+=</span> xpad[n, :, hs:hs <span style="color: #666666">+</span> f_height, ws:ws <span style="color: #666666">+</span> f_width] <span style="color: #666666">*</span> dout[n,f,jj,ii]
          dxpad[n, :, hs:hs <span style="color: #666666">+</span> f_height, ws:ws <span style="color: #666666">+</span> f_width] <span style="color: #666666">+=</span> w[f] <span style="color: #666666">*</span> dout[n,f,jj,ii]

  dx <span style="color: #666666">=</span> dxpad[:,:,pad:pad<span style="color: #666666">+</span>H,pad:pad<span style="color: #666666">+</span>W]
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># END YOUR CODE HERE</span>
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>

  <span style="color: #008000; font-weight: bold">return</span> dx, dw, db


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">max_pool_forward_naive</span>(x, pool_param):
  <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">  A naive implementation of the forward pass for a max pooling layer.</span>

<span style="color: #BA2121; font-style: italic">  Inputs:</span>
<span style="color: #BA2121; font-style: italic">  - x: Input data, of shape (N, C, H, W)</span>
<span style="color: #BA2121; font-style: italic">  - pool_param: dictionary with the following keys:</span>
<span style="color: #BA2121; font-style: italic">    - &#39;pool_height&#39;: The height of each pooling region</span>
<span style="color: #BA2121; font-style: italic">    - &#39;pool_width&#39;: The width of each pooling region</span>
<span style="color: #BA2121; font-style: italic">    - &#39;stride&#39;: The distance between adjacent pooling regions</span>

<span style="color: #BA2121; font-style: italic">  Returns a tuple of:</span>
<span style="color: #BA2121; font-style: italic">  - out: Output data</span>
<span style="color: #BA2121; font-style: italic">  - cache: (x, pool_param)</span>
<span style="color: #BA2121; font-style: italic">  &quot;&quot;&quot;</span>
  out <span style="color: #666666">=</span> <span style="color: #008000">None</span>
  
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># YOUR CODE HERE:</span>
  <span style="color: #408080; font-style: italic">#   Implement the max pooling forward pass.</span>
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  HH <span style="color: #666666">=</span> pool_param[<span style="color: #BA2121">&#39;pool_height&#39;</span>]
  WW <span style="color: #666666">=</span> pool_param[<span style="color: #BA2121">&#39;pool_width&#39;</span>]
  stride <span style="color: #666666">=</span> pool_param[<span style="color: #BA2121">&#39;stride&#39;</span>]
  N, C, H, W <span style="color: #666666">=</span> x<span style="color: #666666">.</span>shape
  Hp <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> (H <span style="color: #666666">-</span> HH) <span style="color: #666666">/</span> stride)
  Wp <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> (W <span style="color: #666666">-</span> WW) <span style="color: #666666">/</span> stride)

  out <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((N, C, Hp, Wp))

  <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(C):
      <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Hp):
        hs <span style="color: #666666">=</span> k <span style="color: #666666">*</span> stride
        <span style="color: #008000; font-weight: bold">for</span> l <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Wp):
          ws <span style="color: #666666">=</span> l <span style="color: #666666">*</span> stride

          window <span style="color: #666666">=</span> x[i, j, hs:hs<span style="color: #666666">+</span>HH, ws:ws<span style="color: #666666">+</span>WW]
          out[i, j, k, l] <span style="color: #666666">=</span> np<span style="color: #666666">.</span>max(window)

  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># END YOUR CODE HERE</span>
  <span style="color: #408080; font-style: italic"># ================================================================ # </span>
  cache <span style="color: #666666">=</span> (x, pool_param)
  <span style="color: #008000; font-weight: bold">return</span> out, cache

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">max_pool_backward_naive</span>(dout, cache):
  <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">  A naive implementation of the backward pass for a max pooling layer.</span>

<span style="color: #BA2121; font-style: italic">  Inputs:</span>
<span style="color: #BA2121; font-style: italic">  - dout: Upstream derivatives</span>
<span style="color: #BA2121; font-style: italic">  - cache: A tuple of (x, pool_param) as in the forward pass.</span>

<span style="color: #BA2121; font-style: italic">  Returns:</span>
<span style="color: #BA2121; font-style: italic">  - dx: Gradient with respect to x</span>
<span style="color: #BA2121; font-style: italic">  &quot;&quot;&quot;</span>
  dx <span style="color: #666666">=</span> <span style="color: #008000">None</span>
  x, pool_param <span style="color: #666666">=</span> cache
  pool_height, pool_width, stride <span style="color: #666666">=</span> pool_param[<span style="color: #BA2121">&#39;pool_height&#39;</span>], pool_param[<span style="color: #BA2121">&#39;pool_width&#39;</span>], pool_param[<span style="color: #BA2121">&#39;stride&#39;</span>]

  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># YOUR CODE HERE:</span>
  <span style="color: #408080; font-style: italic">#   Implement the max pooling backward pass.</span>
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  N,C,H,W <span style="color: #666666">=</span> x<span style="color: #666666">.</span>shape
  H_pad <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #666666">1+</span>(H <span style="color: #666666">-</span> pool_height) <span style="color: #666666">/</span> stride)
  W_pad <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> (W <span style="color: #666666">-</span> pool_width) <span style="color: #666666">/</span> stride)

  dx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(x)

  <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N):
    <span style="color: #008000; font-weight: bold">for</span> c <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(C):
      <span style="color: #008000; font-weight: bold">for</span> jj <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(H_pad):
        hs <span style="color: #666666">=</span> jj <span style="color: #666666">*</span> stride
        <span style="color: #008000; font-weight: bold">for</span> ii <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(W_pad):
          ws <span style="color: #666666">=</span> ii<span style="color: #666666">*</span>stride
          window <span style="color: #666666">=</span> x[n, c, hs:hs<span style="color: #666666">+</span>pool_height, ws:ws<span style="color: #666666">+</span>pool_width]
          m <span style="color: #666666">=</span> np<span style="color: #666666">.</span>max(window)
          dx[n, c, hs:hs<span style="color: #666666">+</span>pool_height, ws:ws<span style="color: #666666">+</span>pool_width] <span style="color: #666666">+=</span> (window <span style="color: #666666">==</span> m) <span style="color: #666666">*</span> dout[n, c, jj, ii]

  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># END YOUR CODE HERE</span>
  <span style="color: #408080; font-style: italic"># ================================================================ # </span>

  <span style="color: #008000; font-weight: bold">return</span> dx

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">spatial_batchnorm_forward</span>(x, gamma, beta, bn_param):
  <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">  Computes the forward pass for spatial batch normalization.</span>
<span style="color: #BA2121; font-style: italic">  </span>
<span style="color: #BA2121; font-style: italic">  Inputs:</span>
<span style="color: #BA2121; font-style: italic">  - x: Input data of shape (N, C, H, W)</span>
<span style="color: #BA2121; font-style: italic">  - gamma: Scale parameter, of shape (C,)</span>
<span style="color: #BA2121; font-style: italic">  - beta: Shift parameter, of shape (C,)</span>
<span style="color: #BA2121; font-style: italic">  - bn_param: Dictionary with the following keys:</span>
<span style="color: #BA2121; font-style: italic">    - mode: &#39;train&#39; or &#39;test&#39;; required</span>
<span style="color: #BA2121; font-style: italic">    - eps: Constant for numeric stability</span>
<span style="color: #BA2121; font-style: italic">    - momentum: Constant for running mean / variance. momentum=0 means that</span>
<span style="color: #BA2121; font-style: italic">      old information is discarded completely at every time step, while</span>
<span style="color: #BA2121; font-style: italic">      momentum=1 means that new information is never incorporated. The</span>
<span style="color: #BA2121; font-style: italic">      default of momentum=0.9 should work well in most situations.</span>
<span style="color: #BA2121; font-style: italic">    - running_mean: Array of shape (D,) giving running mean of features</span>
<span style="color: #BA2121; font-style: italic">    - running_var Array of shape (D,) giving running variance of features</span>
<span style="color: #BA2121; font-style: italic">    </span>
<span style="color: #BA2121; font-style: italic">  Returns a tuple of:</span>
<span style="color: #BA2121; font-style: italic">  - out: Output data, of shape (N, C, H, W)</span>
<span style="color: #BA2121; font-style: italic">  - cache: Values needed for the backward pass</span>
<span style="color: #BA2121; font-style: italic">  &quot;&quot;&quot;</span>
  out, cache <span style="color: #666666">=</span> <span style="color: #008000">None</span>, <span style="color: #008000">None</span>

  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># YOUR CODE HERE:</span>
  <span style="color: #408080; font-style: italic">#   Implement the spatial batchnorm forward pass.</span>
  <span style="color: #408080; font-style: italic">#</span>
  <span style="color: #408080; font-style: italic">#   You may find it useful to use the batchnorm forward pass you </span>
  <span style="color: #408080; font-style: italic">#   implemented in HW #4.</span>
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  
  mode <span style="color: #666666">=</span> bn_param[<span style="color: #BA2121">&#39;mode&#39;</span>]
  eps <span style="color: #666666">=</span> bn_param<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;eps&#39;</span>, <span style="color: #666666">1e-5</span>)
  momentum <span style="color: #666666">=</span> bn_param<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;momentum&#39;</span>, <span style="color: #666666">0.9</span>)
  N,C,H,W <span style="color: #666666">=</span> x<span style="color: #666666">.</span>shape
  running_mean <span style="color: #666666">=</span> bn_param<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;running_mean&#39;</span>, np<span style="color: #666666">.</span>zeros((<span style="color: #666666">1</span>, C, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>), dtype<span style="color: #666666">=</span>x<span style="color: #666666">.</span>dtype))
  running_var <span style="color: #666666">=</span> bn_param<span style="color: #666666">.</span>get(<span style="color: #BA2121">&#39;running_var&#39;</span>, np<span style="color: #666666">.</span>zeros((<span style="color: #666666">1</span>,C, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>), dtype<span style="color: #666666">=</span>x<span style="color: #666666">.</span>dtype))
  out,cache <span style="color: #666666">=</span> <span style="color: #008000">None</span>, <span style="color: #008000">None</span>
  <span style="color: #008000; font-weight: bold">if</span> mode <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;train&#39;</span>:
    sample_mean <span style="color: #666666">=</span> np<span style="color: #666666">.</span>mean(x, axis <span style="color: #666666">=</span> (<span style="color: #666666">0</span>,<span style="color: #666666">2</span>,<span style="color: #666666">3</span>))<span style="color: #666666">.</span>reshape(<span style="color: #666666">1</span>,C,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>)
    sample_var <span style="color: #666666">=</span> <span style="color: #666666">1/</span><span style="color: #008000">float</span>(N<span style="color: #666666">*</span>H<span style="color: #666666">*</span>W) <span style="color: #666666">*</span> np<span style="color: #666666">.</span>sum((x<span style="color: #666666">-</span>sample_mean)<span style="color: #666666">**2</span>, axis<span style="color: #666666">=</span>(<span style="color: #666666">0</span>,<span style="color: #666666">2</span>,<span style="color: #666666">3</span>))<span style="color: #666666">.</span>reshape(<span style="color: #666666">1</span>,C,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>)
    <span style="color: #408080; font-style: italic">#1</span>
    running_mean <span style="color: #666666">=</span> momentum <span style="color: #666666">*</span> running_mean <span style="color: #666666">+</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> momentum) <span style="color: #666666">*</span> sample_mean
    running_var <span style="color: #666666">=</span> momentum <span style="color: #666666">*</span> running_var <span style="color: #666666">+</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> momentum) <span style="color: #666666">*</span> sample_var
    xhat <span style="color: #666666">=</span> (x <span style="color: #666666">-</span> sample_mean) <span style="color: #666666">/</span> np<span style="color: #666666">.</span>sqrt(sample_var <span style="color: #666666">+</span> eps)
    out <span style="color: #666666">=</span> gamma<span style="color: #666666">.</span>reshape(<span style="color: #666666">1</span>,C,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>) <span style="color: #666666">*</span> xhat <span style="color: #666666">+</span> beta<span style="color: #666666">.</span>reshape(<span style="color: #666666">1</span>,C,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>)
    cache <span style="color: #666666">=</span> (x,xhat,sample_mean,sample_var,gamma,beta,eps)

  <span style="color: #008000; font-weight: bold">elif</span> mode <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;test&#39;</span>:
    outhat <span style="color: #666666">=</span> (x <span style="color: #666666">-</span> running_mean)<span style="color: #666666">/</span>np<span style="color: #666666">.</span>sqrt(running_var<span style="color: #666666">+</span>eps)

  <span style="color: #008000; font-weight: bold">else</span>:
    <span style="color: #008000; font-weight: bold">raise</span> <span style="color: #D2413A; font-weight: bold">ValueError</span>(<span style="color: #BA2121">&#39;Invalid ForwardBatchNorm Mode </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> mode)

  bn_param[<span style="color: #BA2121">&#39;running_mean&#39;</span>] <span style="color: #666666">=</span> running_mean
  bn_param[<span style="color: #BA2121">&#39;running_var&#39;</span>] <span style="color: #666666">=</span> running_var
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># END YOUR CODE HERE</span>
  <span style="color: #408080; font-style: italic"># ================================================================ # </span>

  <span style="color: #008000; font-weight: bold">return</span> out, cache


<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">spatial_batchnorm_backward</span>(dout, cache):
  <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">  Computes the backward pass for spatial batch normalization.</span>
<span style="color: #BA2121; font-style: italic">  </span>
<span style="color: #BA2121; font-style: italic">  Inputs:</span>
<span style="color: #BA2121; font-style: italic">  - dout: Upstream derivatives, of shape (N, C, H, W)</span>
<span style="color: #BA2121; font-style: italic">  - cache: Values from the forward pass</span>
<span style="color: #BA2121; font-style: italic">  </span>
<span style="color: #BA2121; font-style: italic">  Returns a tuple of:</span>
<span style="color: #BA2121; font-style: italic">  - dx: Gradient with respect to inputs, of shape (N, C, H, W)</span>
<span style="color: #BA2121; font-style: italic">  - dgamma: Gradient with respect to scale parameter, of shape (C,)</span>
<span style="color: #BA2121; font-style: italic">  - dbeta: Gradient with respect to shift parameter, of shape (C,)</span>
<span style="color: #BA2121; font-style: italic">  &quot;&quot;&quot;</span>
  dx, dgamma, dbeta <span style="color: #666666">=</span> <span style="color: #008000">None</span>, <span style="color: #008000">None</span>, <span style="color: #008000">None</span>

  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># YOUR CODE HERE:</span>
  <span style="color: #408080; font-style: italic">#   Implement the spatial batchnorm backward pass.</span>
  <span style="color: #408080; font-style: italic">#</span>
  <span style="color: #408080; font-style: italic">#   You may find it useful to use the batchnorm forward pass you </span>
  <span style="color: #408080; font-style: italic">#   implemented in HW #4.</span>
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  x,xhat,sample_mean,sample_var,gamma,beta,eps <span style="color: #666666">=</span> cache
  N,C,H,W <span style="color: #666666">=</span> dout<span style="color: #666666">.</span>shape
  dbeta <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(dout,axis<span style="color: #666666">=</span>(<span style="color: #666666">0</span>,<span style="color: #666666">2</span>,<span style="color: #666666">3</span>))
  dgamma<span style="color: #666666">=</span>np<span style="color: #666666">.</span>sum(dout<span style="color: #666666">*</span>xhat, axis<span style="color: #666666">=</span>(<span style="color: #666666">0</span>,<span style="color: #666666">2</span>,<span style="color: #666666">3</span>))
  gamma_reshape <span style="color: #666666">=</span> gamma<span style="color: #666666">.</span>reshape(<span style="color: #666666">1</span>,C,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>)
  beta_reshape <span style="color: #666666">=</span> beta<span style="color: #666666">.</span>reshape(<span style="color: #666666">1</span>,C,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>)
  V <span style="color: #666666">=</span> N <span style="color: #666666">*</span> H <span style="color: #666666">*</span> W
  dxhat <span style="color: #666666">=</span> dout <span style="color: #666666">*</span> gamma_reshape

  mdvar <span style="color: #666666">=</span> np<span style="color: #666666">.</span>sum(dxhat <span style="color: #666666">*</span> (x <span style="color: #666666">-</span> sample_mean), axis <span style="color: #666666">=</span> (<span style="color: #666666">0</span>,<span style="color: #666666">2</span>,<span style="color: #666666">3</span>))<span style="color: #666666">.</span>reshape(<span style="color: #666666">1</span>,C,<span style="color: #666666">1</span>,<span style="color: #666666">1</span>)
  dvar <span style="color: #666666">=</span> mdvar <span style="color: #666666">*</span> <span style="color: #666666">-1/2</span> <span style="color: #666666">*</span> (sample_var <span style="color: #666666">+</span> eps) <span style="color: #666666">**</span> (<span style="color: #666666">-3/2</span>)
  ds <span style="color: #666666">=</span> <span style="color: #666666">1/</span>V <span style="color: #666666">*</span> np<span style="color: #666666">.</span>broadcast_to(np<span style="color: #666666">.</span>broadcast_to(np<span style="color: #666666">.</span>squeeze(dvar), (W,H,C))<span style="color: #666666">.</span>transpose(<span style="color: #666666">2</span>,<span style="color: #666666">1</span>,<span style="color: #666666">0</span>), (N,C,H,W))
  dx1 <span style="color: #666666">=</span> dxhat <span style="color: #666666">/</span> np<span style="color: #666666">.</span>sqrt(sample_var <span style="color: #666666">+</span> eps) <span style="color: #666666">+</span> <span style="color: #666666">2</span> <span style="color: #666666">*</span> (x<span style="color: #666666">-</span>sample_mean) <span style="color: #666666">*</span> ds
  dmu <span style="color: #666666">=</span> <span style="color: #666666">-1</span> <span style="color: #666666">*</span> np<span style="color: #666666">.</span>sum(dx1, axis <span style="color: #666666">=</span> (<span style="color: #666666">0</span>,<span style="color: #666666">2</span>,<span style="color: #666666">3</span>))
  dx2 <span style="color: #666666">=</span> <span style="color: #666666">1/</span>V <span style="color: #666666">*</span> np<span style="color: #666666">.</span>broadcast_to(np<span style="color: #666666">.</span>broadcast_to(np<span style="color: #666666">.</span>squeeze(dmu), (W,H,C))<span style="color: #666666">.</span>transpose(<span style="color: #666666">2</span>,<span style="color: #666666">1</span>,<span style="color: #666666">0</span>), (N,C,H,W))
  dx <span style="color: #666666">=</span> dx1<span style="color: #666666">+</span>dx2
  <span style="color: #408080; font-style: italic"># ================================================================ #</span>
  <span style="color: #408080; font-style: italic"># END YOUR CODE HERE</span>
  <span style="color: #408080; font-style: italic"># ================================================================ # </span>

  <span style="color: #008000; font-weight: bold">return</span> dx, dgamma, dbeta
</pre></div>
</body>
</html>
